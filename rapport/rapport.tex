\documentclass[a4paper]{article}%{{{

\usepackage[utf8]{inputenc}%{{{
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage{url}
\usepackage{hyperref}
\usepackage[top=2.5cm,bottom=2.5cm,right=2.5cm,left=2.5cm]{geometry}
\usepackage[french]{babel}
\usepackage[backend=biber,style=ieee]{biblatex}
%\usepackage{titletoc}% http://ctan.org/pkg/titletoc
\usepackage{qtree}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{setspace}
\usepackage{graphicx}
\usepackage{geometry}
\usepackage{titlesec}%}}}

\addbibresource{refs.bib}

\definecolor{codegreen}{rgb}{0,0.6,0}%{{{
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
\definecolor{backpink}{rgb}{1,0.94,0.95}
%}}}
\lstdefinestyle{codestyle}{%{{{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{teal},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    %numbers=left,
    %numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2
}
%}}}
\lstdefinestyle{grammarstyle}{%{{{
    backgroundcolor=\color{backpink},
    commentstyle=\color{codegreen},
    keywordstyle=\color{purple},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{teal},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    %numbers=left,
    %numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2
}
%}}}
\lstnewenvironment{code}[1][]%{{{
  {\noindent\minipage{\linewidth}\medskip
   \lstset{basicstyle=\ttfamily\footnotesize,frame=single,#1,upquote=true}
    \lstset{style=codestyle}
     }
  {\endminipage}

 \lstnewenvironment{grammar}[1][]
  {\noindent\minipage{\linewidth}\medskip
   \lstset{basicstyle=\ttfamily\footnotesize,frame=single,#1,upquote=true}
   \lstset{style=grammarstyle}
   }
  {\endminipage}
%}}}
%===========style & geometry==========={{{
%\lstset{style=mystyle}

 \geometry{
 a4paper,
  left=30mm,
  right=20mm,
  top=25mm,
  bottom=25mm,
 }

 \titleformat*{\section}{\LARGE\bfseries}
 \titleformat*{\subsection}{\Large\bfseries}
%}}}
%================infos================={{{
\pagenumbering{gobble}
\begin{titlepage}

\title{Création d'un langage interprété}
\author{Franck ALONSO, CHASSAGNOL Rémi}
\date{\today}
\end{titlepage}
%}}}}}}

%------------------------------------------------------------------------------%
%                                  Title page                                  %
%------------------------------------------------------------------------------%
\begin{document}
\input{titlepage.tex}
\clearpage{}


%------------------------------------------------------------------------------%
%                                Remerciements                                 %
%------------------------------------------------------------------------------%
\section*{Remerciements}

\doublespacing
\large % TODO: reformuler
Nous tenons à exprimer notre profonde gratitude à :\\
- Notre encadrant et cher professeur M. Loïc YON pour al qualité de son
  encadrement, et pour nous avoir guidées durant toute la période du projet.\\
- Mme Murielle MOUZAT, notre professeur de communication pour son aide précieuse
  et indispensable pour la réussite de notre projet de 2\up{ème} année.\\

\noindent Finalement, nous exprimons nos vifs remerciements à toute personne
ayant participée de près ou de loin au bon déroulement de ce projet.

\normalsize
\onehalfspacing

\clearpage{}

%------------------------------------------------------------------------------%
%                               Table of contents                              %
%------------------------------------------------------------------------------%
\pagenumbering{arabic}
\thispagestyle{empty}
\tableofcontents
\clearpage{}


%------------------------------------------------------------------------------%
%                               Table of figures                               %
%------------------------------------------------------------------------------%
%\listoffigures
\clearpage{}


%------------------------------------------------------------------------------%
%                              Résumé et Abstract                              %
%------------------------------------------------------------------------------%

\setcounter{secnumdepth}{0}
\section{Résumé}
L'objectif de ce projet est la création d'un langage \textbf{transpilé} en
\textbf{C++} dans le but de faire découvrir l'informatique et la programmation à
des collégiens et lycéens. Ce projet rentre dans le cadre du sujet commun de la
filière F2, qui concerne la conception d’outils et plus généralement en
développement logiciel.

Ce projet s'inscrit dans le cadre du projet commun de la filière 2. L'objectif
du projet commun est la création d'outils de démonstration servant à présenter
la filière génie logiciel. Notre travail a consisté en la création d'un langage
de programmation transpilé. Pour ce faire, nous avons du étudier des concepts et
des outils utilisés pour la création de compilateurs. % TODO: trouver mieux
% TODO: mentionner C++
\\~\\

\noindent
Mots-clés : \textbf{C++}, \textbf{transpileur}, \textbf{lexeur},
\textbf{parseur}, \textbf{flex}, \textbf{bison},  \textbf{langage de
programmation}
\\[2\baselineskip]

\section{Abstract}

The objective of this project is the creation of an \textbf{transpiled}
language  in \textbf{C++} in order to introduce computer science and programming
to middle and high school students. This project falls within the framework of
the common subject of the F2 major, which relates to the design of tools and
more generally in software development.
\\~\\

\noindent
Keywords : \textbf{C++}, \textbf{interpreter}, \textbf{lexer}, \textbf{parser},
\textbf{programming language}

\clearpage{}


%------------------------------------------------------------------------------%
%                                 Introduction                                 %
%------------------------------------------------------------------------------%
\section{Introduction}
\large
Dans le cadre du projet de 2\up{ème} année à l'ISIMA, nous avons choisi de
réaliser un travail concernant le sujet commun de la filière 2, génie logiciel
et systèmes d'informations. Le but du projet commun est la création d'outils de
démonstration servant à présenter la filière.\\

Nous souhaitions au départ, créer un langage de programmation interprété ainsi
qu'un IDE, cependant, ce projet s'est avéré trop ambitieux pour être réalisé en
60 heures. Pour simplifier, nous avons décidé de concevoir un langage transpilé,
délégant ainsi une partie des tâches complexes comme la gestion de la mémoire à
un compilateur existant.\\

Ce projet permettra de présenter un langage de programmation très simple pour
introduire des lycéen à la programmation. De plus, il pourra constituer une
maquette pour les élèves de l'ISIMA souhaitant étudier le fonctionnement des
compilateurs.\\

Pour présenter ce projet, nous commencerons par la forme du langage à créer
souhaité, puis nous détaillerons sa structure. Une fois familiarisé avec les
différentes étapes de son implémentation,  nous introduirons les concepts et
outils informatiques qui permettent la réalisation de notre langage.\\

\normalsize
\clearpage{}


%------------------------------------------------------------------------------%
%               Résumé des réfs (à supprimer à la dernière version             %
%------------------------------------------------------------------------------%
% TODO: à enlever
\section{Résumé des références}

\begin{itemize}
  \item La partie consultable de \cite{flexBisonHandbook} présentent les bases
    de flex.
  \item \cite{compilerFlexBison} présente la construction d'un compilateur avec
    flex et bison. Le compilateur présenté utilise une \textbf{table des
    symboles} ainsi qu'une sorte de \textbf{byte code}. Nous avons choisi
    l'autre méthode qui consiste à utiliser un object-ABS plutot que directement
    du byte code. Article très utilisé au départ pour la mise en place du
    parseur/lexeur.
  \item \cite{flexmanual}: manuel d'utilisation de Flex.
  \item \cite{cppparsing}: nous a permis d'avoir un exemple de code qui allie
    flex et bison en C++ et non en C.


  \item \cite{compilerTICH} explication du fonctionnement d'un compilateur.
  \item \cite{compilerTILB} première version de l'article précédent.
  \item \cite{crew1997astlog} création d'un analyser syntaxique pour du C/C++:
    ASTROLOG. L'article par d'analyse syntaxique et de la construction
    d'\textbf{ABS}.

  \item \cite{visser2002meta} L'objectif de l'article est de présenter
    l'utilisation des \textbf{ABS} pour de la méta programmation. Il comporte
    pas mal d'exemples sur les \textbf{ABS} donc je le trouve pertinant.
  \item \cite{gagnon1998sablecc}: \textbf{ABS} en java.
\end{itemize}


\clearpage{}
\setcounter{secnumdepth}{1}

%------------------------------------------------------------------------------%
%                                     Plan                                     %
%------------------------------------------------------------------------------%

% NOTE: les partie ne sont pas très équilibrées

\section{Conception d'une grammaire}

\subsection{Définition de la grammaire}%{{{

Avant d'implémenter notre langage informatique, il faut avoir une idée de sa
grammaire. Puisque nous souhaitons utiliser ce langage à des fins pédagogiques,
nous avons décider de simplifier au maximum la syntaxe. Par exemple, nous avons
choisit de supprimer tous les opérateurs, ainsi, toutes les opérations
arithmétiques et booléennes auront la même syntaxe que les fonctions. Par
exemple, $a+b$ s'écrira \textit{add}(\textbf{a}, \textbf{b}). De plus, pour
différer au maximum de python, notre syntaxe s'inspirera de celle des langages
\textbf{C} et \textbf{Rust}. Pour définir la grammaire de manière formelle, nous
utiliserons la forme de Backus-Naur.
% TODO: cite !!!

\subsubsection{Les variables}

Pour stocker des données, notre langage utilise des variables dont la
convention de nommage est la même qu'en \textbf{C}. Le langage est à typage
statique, ce qui signifie que toutes les variables doivent être déclarée avec
leur type avant d'être utilisées. Pour l'instant, nous possédons trois types :
les entiers (\textit{int}), les nombre à virgule flottante (\textit{flt}) et les
caractères (\textit{chr}). Voici la syntaxe pour déclarer une variable:

\begin{grammar}
<identifier> ::= 'a'-'z'( <alpha> | '0'-'9' )*
<int> ::= "int"
<flt> ::= "flt"
<chr> ::= "chr"
<type> ::= <int> | <flt> | <chr>
<declaration> ::= <type> <identifier> ";"
\end{grammar}\leavevmode\newline

\subsubsection{Les fonctions}

Pour définir des fonctions, nous utilisons le mot clé \textbf{fn}, suivit du nom
de la fonction avec ses paramètres entre parenthèses et enfin le bloque de code
qui contient les instructions entre accolade. De plus, il faut spécifier le type
de la valeur retour de la fonction en utilisant \textbf{-> type} quand c'est
nécessaire.

\begin{grammar}
<function> ::= fn <identifier>"("<parameters>")" [ "->" <type> ] "{"<instructions>"}"
\end{grammar}\leavevmode\newline

Pour pouvoir retourner une valeur, il faudra utiliser le mot clé \textit{return}
dans la fonction.

\subsubsection{Les structures de contrôle}

Nous avons aussi ajouté les structures de contrôle présentes dans la plupart des
langages de programmation.

\begin{grammar}
<if> ::= if "("<condition>")" "{"<instructions>"}" [ else "{" <instructions>"}" ]

<range> ::= range "("<valueSymbol>, <valueSymbol>, <valueSymbol>")"
<for> ::= for <identifier> in <range> "{"<instructions>"}"

<while> ::= while "("<condition>")" "{" <instructions> "}"
\end{grammar}\leavevmode\newline

\subsubsection{Les opérations}

Comme dit précédemment, tous le langage ne comporte pas d'opérateur donc toutes
les opérations se font à l'aide de fonctions directement intégrées dans le
transpileur. Voici une liste des opérations possibles :

\begin{center}
\begin{tabular}{ | c | c | }
    \hline
    opération & syntaxe\\
    \hline
    \textbf{a} + \textbf{b} & \textit{add}(\textbf{a}, \textbf{b})\\
    \hline
    \textbf{a} - \textbf{b} & \textit{mns}(\textbf{a}, \textbf{b})\\
    \hline
    \textbf{a} $\times$ \textbf{b} & \textit{tms}(\textbf{a}, \textbf{b})\\
    \hline
    \textbf{a} $\div$ \textbf{b} & \textit{div}(\textbf{a}, \textbf{b})\\
    \hline
    \textbf{a} \textbf{==} \textbf{b} & \textit{eql}(\textbf{a}, \textbf{b})\\
    \hline
    \textbf{a} \textbf{<} \textbf{b} & \textit{inf}(\textbf{a}, \textbf{b})\\
    \hline
    \textbf{a} \textbf{>} \textbf{b} & \textit{sup}(\textbf{a}, \textbf{b})\\
    \hline
    \textbf{a} \textbf{<=} \textbf{b} & \textit{ieq}(\textbf{a}, \textbf{b})\\
    \hline
    \textbf{a} \textbf{>=} \textbf{b} & \textit{seq}(\textbf{a}, \textbf{b})\\
    \hline
    \textbf{not} \textbf{a} & \textit{not}(\textbf{a})\\
    \hline
\end{tabular}
\end{center}

\subsubsection{Inclusion de fichier}

TODO: Non fonctionnel :/

\subsubsection{Entrée et sortie}

Le langage possède aussi la possibilité d'afficher et de lire du texte depuis la
console. La lecture se fait avec la fonction \textit{read} qui prend en
paramètre une variable qui stockera le résultat. Pour la l'affichage, il faudra
utiliser la fonction \textit{print} qui peut être utilisée de deux manières :

\begin{itemize}
  \item \lstinline{print("Hello, World!")} : affiche du texte
  \item \lstinline{print(variable)} : affichage d'une valeur (depuis une
    variable ou une fonction).
\end{itemize}

\subsubsection{Exemple de code}

Dans cet exemple, nous disposons de 2 variables \textbf{a} et \textbf{b}. La
variable \textbf{a} est lue par commande de l'utilisateur tandis que la valeur 4
est assignée à \textbf{b}.\\
Nous cherchons ensuite à additionner les 2 variables avec la valeur 5. Nous avons alors la syntaxe suivante :\\
- une fonction \textit{add3} qui additionne les valeurs de ses 3 paramètres\\
- une fonction \textit{affiche} qui affiche sur l'écran le nombre passé en paramètre\\
- une fonction \textit{main}, où se trouve toutes les commandes voulues de notre programme\\

% section  (end)


\begin{grammar}[language=C++]
fn add3(int a, int b, int c) -> int {
    return add(a, add(b, c));
}

fn affiche(int n) {
    print("nombre : ");
    print(n);
}

fn main() {
    int a;
    int b;
    read(a);
    set(b, 4);
    affiche(add3(a, b, 5));
}
\end{grammar}\leavevmode\newline


\clearpage{}
%}}}
\subsection{Arbre syntaxique}%{{{

Pour donner un sens aux éléments textuels du langage, nous utiliseront une
représentation sous forme d'arbre. On appel cela un arbre syntaxique ou AST
(Abstract Syntax Tree). Les arbres syntaxiques sont nés avec la théorie des
langages et comme on peut le voir dans cet article \cite{compilerTICH}, les AST
sont très utilisés par les compilateurs car ce sont des structures plus simples
à manipuler que du texte. Voici l'arbre syntaxique de la fonction \textit{add3} :

\begin{figure}[h]
  \begin{center}
  \includegraphics[scale=0.4]{img/ast1.png}
  \caption{Exemple d'arbre syntaxique}
  \end{center}
\end{figure}

Pour cette partie, nous nous sommes inspiré d'un projet appelé \textbf{minijava}
\cite{minijava} ainsi que d'un article \cite{gagnon1998sablecc} qui couvre aussi
l'utilisation des AST en java. Nous avons choisit l'approche objet, avec un AST
représenté par des classes, où chaque nœud de l'arbre a sa propre classe.\\

Toutes les classes de l'arbre sont stockées dans le fichier
\lstinline{AST/AST.hpp} et héritent toutes d'une classe abstraite
\lstinline{ASTNode}. L'emploi de l'héritage ici est très important car
nous profiterons par la suite des avantages du polymorphisme pour stocker des
opérations de différents types. La classe \lstinline{ASTNode} est abstraite car
elle ne doit pas être instanciée, il faut que chaque nœud ai un type concret
utilisable dans le transpileur. Le diagramme de classes complet est disponible
en annexe \ref{appendix:classAST}. Détaillons maintenant les parties
importantes.

\subsubsection{Les bloques de code}

La classe \lstinline{Block} correspond aux bloques de code en entre accolades.
Elle possède une liste de nœuds qui sont les opérations contenues dans le
bloque.

\subsubsection{Les conteneurs d'opérations}

La classes \lstinline{Statement} correspond aux éléments qui contiennent des
blocks de code. Cela comprend les fonctions et les structures de contrôles. La
grammaire ne permet pas l'emploi des bloques ailleurs.

\begin{figure}[h]
  \begin{center}
  \includegraphics[scale=0.5]{../ressources/diagrams/stmts.png}
  \caption{Classe Statement}
  \end{center}
\end{figure}
\subsubsection{Les opérations}

Les opérations sont traitées avec la classe \lstinline{OperationBinaire} qui
correspond à tous les opérateurs.

% TODO: img

%}}}

\section{Construction de l'AST}

\subsection{Flex}%{{{

\phantomsection
\subsubsection{Définition}

Le lexeur, ou encore appelé analyseur lexical, a pour but de transformer le
texte du code source en des unités lexicales, appelées \textit{tokens}, comme
expliqué par la partie consultable de  \cite{flexBisonHandbook}. \\

\textbf{Exemple} \\
    Pour l'expression simple \textbf{a = 2 * b} \\
    Les tokens apparaissant sont : \\
    \begin{center}
    \begin{tabular}{ | c | c | }
    \hline
    \textbf{Token} & \textbf{Sa nature} \\
    \hline
    a & Identificateur de variable \\
    \hline
    = & Symbole d'affectation \\
    \hline
    2 & Valeur entière \\
    \hline
    * & Opérateur de multiplication \\
    \hline
    b & Identificateur de variable \\
    \hline
\end{tabular}
\end{center}

Le lexeur a également pour rôle de supprimer les informations inutiles,
généralement du caractère espace et des commentaires.\\~\\


\phantomsection
\subsection{Implémentation}

L'outil utilisé pour générer un lexeur à partir du code précédent est Flex (Fast
LEXical analyser generator). Au lieu d'écrire un lexeur à partir de zéro, Flex
permet d'avoir un lexeur en donnant seulement les modèles des expressions
régulières ainsi que le langage de travail (c++ dans notre cas).\\

\cite{compilerFlexBison} a fourni un squelette pour la réalisation du fichier
nécessaire à Flex.\\~\\

\noindent

Le fichier \textbf{main\_cpp.l} contient le code qui permet de générer le lexeur
avec Flex. Les token doivent-être définis dans \textbf{main\_cpp.y} au
préalable.
À noter que l'on peut utiliser la variable \lstinline{yylval} pour transmettre
des éléments au parser.\\

La structure du fichier \textbf{main\_cpp.l} est la suivante :

\begin{code}
C and parser declaration

%%
Grammar rules and actions

%%
C subroutings
\end{code}\leavevmode\newline


\noindent
On peut definir des règles dans les déclarations du lexeur :

\begin{code}
%option c++ interactive noyywrap noyylineno nodefault outfile="lexer.cpp"

alpha [a-zA-Z]
digit [0-9]
int [+-]?{digit}+
float [+-]?{digit}+\.{digit}+
char '{alpha}'
identifier [a-z]({alpha}|{digit}|_)*
\end{code}\leavevmode\newline

\noindent
Concernant la ligne d'option :
\begin{itemize}
\item \textbf{c++} : indique qu'on travail avec du cpp et non du c
\item \textbf{interactive} : utile quand on utlise \textbf{std::in}. Le scanner interactif regarde plus de caractères avant de générer un token (plus lent mais permet de lutter contre les ambiguitées)
\item \textbf{noyywrap} : ne pas appeler \textbf{yywrap()} qui permet de parser plusieurs fichiers
\item \textbf{noyylineno}: désactive l'enregistrement des lignes (\textbf{yylineno})
\item \textbf{nodefault} : pas de scanner par défaut (=> on doit tout implémenter)
\item \textbf{outfile:"file.cpp"} : permet de definir le fichier de sortie
\end{itemize}\leavevmode\\[3\baselineskip]


\noindent
Dans les règles, on suit toujours le même principe, on indique les caractères à reconaitre puis on exécute du code :\\

\begin{code}
for          { AFFICHE("L_for"); return Parser::token::FOR; }
{identifier} {
  AFFICHE("L_id");
  yylval->build<std::string>(yytext);
  return Parser::token::IDENTIFIER;
}
\end{code}\leavevmode\newline

\noindent
Ici on a accès à la variable \textcolor{purple}{yylval} qui est un \textcolor{purple}{Parser::semantic\_type*} et qui possède une méthode \textcolor{purple}{build} qui nous permet de transmettre des valeurs à bison.\\
Ces valeurs sont accessible via les variables de bison: \textcolor{purple}{\$2}. La variable
\textcolor{purple}{yytext} contient le text traité par Flex. De plus, dans le code, on retourne
les \textit{tokens}. Ces \textbf{tokens} sont définis dans le fichier de bison.
\newline

La fonction appelée par défaut est \textcolor{purple}{yylex}, cependant, pour pouvoir travailler avec bison, nous devons fournir nos propres fonctions, pour ce faire on utilise la macro \textcolor{purple}{YY\_DECL}, comme expliqué dans la partie \textit{9 The Generated Scanner} du manuel pour Flex \cite{flexmanual}.

\begin{code}
#define YY_DECL int interpreter::Scanner::lex(interpreter::Parser::semantic_type *yylval)
\end{code}\leavevmode\\~\\

\clearpage{}
%}}}
\subsection{Bison}%{{{

\phantomsection
\subsection{Définition}

Également appelé analyseur syntaxique, son rôle principal est la vérification de la syntaxe du code en regroupant les tokens selon une structure suivant des rêgles syntaxiques. \\


    \textbf{Exemple} \\
    Pour l'expression simple \textbf{a = 2 * b} \\
    Les tokens apparaissant sont : \\
    \begin{center}
    \begin{tabular}{ | c | c | c | }
    \hline
    \textbf{Arbre syntaxique} & \textbf{Évaluation de 2 * b} & \textbf{Affectation de a} \\
    \hline
    \Tree[.= a  [.* 2 b ]] &
        \Tree[.= a  2*b ] &
            a = 2 * b\\
    \hline
    \end{tabular}
    \end{center}

\phantomsection
\subsection{Implémentation}

À l'instar de Flex pour le lexeur, Bison est un générateur de grammaire qui convertit une description de grammaire en un programme C++ qui analyse cette même grammaire.\\
L'article \cite{compilerFlexBison} s'est encore une fois révélé très utile pour la réalisation du fichier nécessaire à Bison\\~\\
 Le fichier \textbf{main\_cpp.y} contient le code qui permet de générer le parseur avec Bison. Toutes les règles syntaxiques qui définissent la grammaire du langage y sont comprises.
Chaque règle va contenir des blocks de code qui seront exécutés au moment où le parseur la reconnait, ce code permet de créer des objets qui formeront l'ABS (Abstract Syntaxic Tree) du programme.\\


La structure du fichier \textbf{main\_cpp.y} est identique au lexeur :

\begin{code}
C and parser declaration

%%
Grammar rules and actions

%%
C subroutings
\end{code}\leavevmode\newline

Les tokens sont définis en début de fichier avec la syntaxe suivante:

\begin{code}
%token IF ELSE FOR WHILE FN INCLUDE IN
%token <long long>  INT
%token <double>     FLOAT
%token <char>       CHAR
%token <std::string> IDENTIFIER
\end{code}\leavevmode\newline

À noter que l'on peut spécifier le type de l'élément, ce qui sera utile pour
récupérer les valeurs retournées par le lexeur.\\~\\


Bison permet de construire le parser, qui va reconnaître des éléments de syntaxe
et non pas juste des mots clés. Par exemple, on peut définir une règle pour
reconnaître une suite d'inclusion de fichiers :\\

\begin{code}[language=c++]
includes: %empty
       | INCLUDE IDENTIFIER SEMI includes
       ;
\end{code}\leavevmode\newline

Ici, on définie une règle \textbf{includes} qui décrit la syntaxe des \textit{includes}. Selon cette règle, une suite d'inclusions est soit vide, soit elle comporte une inclusion, suivit d'une suite d'inclusion (`|` signifie "ou"). Il faut noter que la syntaxe est "récursive", ce qui nous permet de définir une suite d'éléments.
Enfin, les mots en majuscule sont les tokens retournés par le lexeur.\\

On peut ajouter des blocks de codes qui seront exécutés au moment où le parseur
atteint l'élément qui précède le block. Dans l'exemple ci-dessous, le block sera appelé une fois que Bison aura parser le \textcolor{purple}{;}. À noter que l'on peut accéder aux éléments retournés par Flex ; ici, \textcolor{purple}{\$2} fait référence au second élément de la règle qui est \textcolor{purple}{IDENTIFIER}. Le type de \textcolor{purple}{IDENTIFIER} a été défini comme étant une \textcolor{purple}{std::string}. Le block de code nous permet donc de créer une nouvelle inclusion et de récupérer le nom de la bibliothèque.\\

\begin{code}[language=c++]
includes: %empty
       |
       INCLUDE IDENTIFIER SEMI
       {
         std::cout << "new include id: " << $2 << std::endl;
         pb.addInclude(std::make_shared<Include>($2));
       }
       includes
       ;
\end{code}\leavevmode\newline


Comme dit plus haut, on peut définir des types pour les tokens, ce qui permet de
récupérer des valeurs:

\begin{code}[language=c++]
value: INT {
       std::cout << "new int: " << $1 << std::endl;
       lastValue.i = $1;
       lastValueType = INT;
     } | FLOAT {
       std::cout << "new double: " << $1 << std::endl;
       lastValue.f = $1;
       lastValueType = FLT;
     } | CHAR {
       std::cout << "new char: " << $1 << std::endl;
       lastValue.c = $1;
       lastValueType = CHR;
     }
     ;
\end{code}\leavevmode\newline

Pour la génération du code, on a deux options :
\begin{itemize}
\item utiliser des instruction très simples => sorte de bytecode
\item créer un code objet où tous les éléments sont des objets.
\end{itemize}\leavevmode\\~\\

\underline{Choix de la représentation objet} :
\begin{itemize}
\item plus simple à comprendre et à visualiser
\item plus compliqué à générer: on peut générer du bytecode au fil de l'exécution du parseur, en utilisant des \textcolor{orange}{goto} pour sauter de block d'instruction en block d'instruction. Pour le code objet, les éléments à l'intérieurs des blocks doivent être créés avant le block, et le block est détecté avant les instructions, il faut donc stocker les instructions.
\end{itemize}


\clearpage{}
%}}}
\subsection{Fabrique à programme}

\section{Analyse des symboles}



\subsection{Création d'une table des symboles}
\subsection{Traitement des des symboles dans le parseur}

\section{Le transpilleur}
% TODO

\section{Conception d'un langage informatique}

%------------------------------------------------------------------------------%
%                                      LEXER                                   %
%------------------------------------------------------------------------------%


%------------------------------------------------------------------------------%
%                                      PARSER                                  %
%------------------------------------------------------------------------------%

\section{Le parseur}%{{{

%------------------------------------------------------------------------------%
%                                 bibliography                                 %
%------------------------------------------------------------------------------%
\printbibliography[keyword={paper},title={Biliographie}]
\printbibliography[keyword={web},title={Webographie}]

\appendix

\clearpage
\section{Diagramme de classes de l'AST}\label{appendix:classAST}

\begin{figure}[h]
  \begin{center}
  \rotatebox[origin=c]{90}{\includegraphics[scale=0.22]{../ressources/diagrams/ast.png}}
  \end{center}
\end{figure}

\end{document}
